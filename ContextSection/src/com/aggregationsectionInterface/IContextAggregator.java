package com.aggregationsectionInterface;


import java.util.Map;
import com.contextsectionInterface.IDataContextCore;


public interface IContextAggregator {
	/*
	 * When a 'Context Provider' generates new data and this is stored in the
	 * system, the module 'Data Repository module notifies the 'Context
	 * Aggreggator', sending the concrete data that has been added to the
	 * system. When a data is updated is necessary to recover the aggregates
	 * affected by the update, evaluate and check the changes therein and warn
	 * if necessary the upper module.
	 */
	void onDataRepositoryChange(IDataContextCore data, String modification);

	/*
	 * When new data is entered into the system and the module 'Aggreggator
	 * Context' is told about it, this must refer to the module 'Aggreggation
	 * Repository' to recover aggregates status may change. To consider an
	 * aggregate is subject of change, assessing the associated event (one that
	 * is generated by the same 'Context Provider' and function that generated
	 * the data) must be different from the previous assessment of the aggregate
	 * (assumed an aggregate has been evaluated as true when it is stored in the
	 * attribute 'activeAggreggations').
	 */
	Map<Integer, IAggregateCore> getAffectedAggregates(IDataContextCore data);

	/*
	 * Method 'checkAggreggates' is a helper method, designed to parallelize the
	 * evaluation of various aggregates using successive calls to the method
	 * 'checkAggreggate'. This method receives a set of input, evaluates it and
	 * returns only those that are evaluated to true.
	 */
	void checkAggregates(Map<Integer, IAggregateCore> newAggregations);

	/*
	 * First decompose the addition of a set of 'IEvent', for which queries the
	 * module 'Aggreggation Repository'. For each Event is responsible to
	 * execute 'checkEvent' and retrieve the associated value. We carried out
	 * the evaluation of the combination (a combination execution in the system
	 * is unimportant since it is only necessary to apply the evaluation of the
	 * comparison between Boolean attributes).
	 */
	Boolean checkAggregate(Integer idAggregate, IAggregateCore aggregate);

	/*
	 * The module 'Context Aggreggator' stores a set of aggregates along with
	 * its associated state. This attribute requires access methods to query,
	 * insert and delete, just as happens to all storage attributes.
	 * 
	 * The query attribute 'activatedAggreggation' is performed to check the
	 * status of a particular aggregate. Method 'isAggreggationActivated' query
	 * attribute 'activatedAggreggation', returning the data value associated
	 * with the key identifier (added) passed as an argument.
	 */
	// Unnecessary: Boolean isAggreggationActivated(String
	// newActiveApplications);

	/*
	 * The module 'Context Aggreggator' stores a set of aggregates along with
	 * its associated state. As seen in the previous method, this attribute
	 * requires access methods to query, insert and delete, just as happens to
	 * all storage attributes.
	 * 
	 * When the method 'changeAggreggationState' To change the value of an
	 * aggregate nonexistent, you need to add it to the repository. Method
	 * 'addActiveAggreggation' is responsible for providing the attribute of
	 * this functionality, so that the attribute is dynamic.
	 */
	// Unnecessary: Void addActiveAggreggation(String newActiveApplications,
	// Boolean newState);

	/*
	 * The module 'Context Aggreggator' stores a set of aggregates along with
	 * its associated state. As seen in the previous method, this attribute
	 * requires access methods to query, insert and delete, just as happens to
	 * all storage attributes.
	 * 
	 * When you delete a repository added (module 'Aggreggation Repository) it
	 * sends to the module' Context Aggreggator 'a message to be responsible to
	 * remove all traces of the same attribute' activeAggreggation '.
	 * 
	 * It uses the method 'removeActiveAggreggation', which is responsible for
	 * deleting a record attribute 'activeAggreggation', whose key is passed as
	 * an input parameter.
	 */
	// Unnecessary: String removeActiveAggreggation(String activeApplications);

	/*
	 * Just as in the previous methods discussed the necessity of providing the
	 * attribute storage module 'Aggreggator Context' access methods for
	 * consultation, insertion and deletion, it is necessary to provide both the
	 * ability to modify a record thereof manner as for all storage attributes.
	 * This functionality is used, because each time you update the value of an
	 * aggregate must also be updated in the attribute 'activatedAggreggation'.
	 * 
	 * Method 'changeAggreggationState' manages updating the value of a register
	 * associated with a key that is passed as an argument, which matches the
	 * identifier of a particular aggregate.
	 * 
	 * However, it is possible that the system has not yet added to the
	 * attribute record, which is because it is the first time that the event
	 * has updated the system, making it necessary to add the record to the
	 * repository. This is responsible for notifying the function
	 * 'addActiveAggreggation', delegating adding registry.
	 */
	// Unnecessary: Void changeAggreggationState(String activeApplications,
	// Boolean state);

}
